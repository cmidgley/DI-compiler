{"version":3,"file":"index.js","sources":["../../src/transformer/constant.ts","../../src/transformer/before/util.ts","../../src/transformer/before/visitor/visit-class-like-declaration.ts","../../src/util/ts-util.ts","../../src/transformer/before/visitor/visit-call-expression.ts","../../src/transformer/before/visitor/visit-node.ts","../../src/transformer/before/before-transformer.ts","../../src/transformer/after/visitor/visit-root-block.ts","../../src/transformer/after/visitor/visit-root-block-source-file.ts","../../src/transformer/after/visitor/visit-root-block-block.ts","../../src/transformer/after/visitor/visit-define-array-literal-expression.ts","../../src/transformer/after/visitor/visit-node.ts","../../src/transformer/after/after-transformer.ts","../../src/transformer/di.ts"],"sourcesContent":["export const CONSTRUCTOR_ARGUMENTS_SYMBOL_IDENTIFIER = `___CTOR_ARGS___`;\nexport const DI_CONTAINER_NAME = \"DIContainer\";\n","import { TS } from \"../../type/type\";\nimport { VisitorContext } from \"../visitor-context\";\n\n/**\n * A TypeNode such as IFoo<string> should still yield the service name \"IFoo\".\n * This helper generates a proper service name from a TypeNode\n */\nexport function pickServiceOrImplementationName(\n  node: TS.Expression | TS.TypeNode | TS.EntityName,\n  context: VisitorContext\n): string {\n  const { typescript } = context;\n\n  if (typescript.isTypeReferenceNode(node)) {\n    return pickServiceOrImplementationName(node.typeName, context);\n  } else if (typescript.isIndexedAccessTypeNode(node)) {\n    return `${pickServiceOrImplementationName(\n      node.objectType,\n      context\n    )}[${pickServiceOrImplementationName(node.indexType, context)}]`;\n  } else {\n    return node.getFullText().trim();\n  }\n}\n","import { CONSTRUCTOR_ARGUMENTS_SYMBOL_IDENTIFIER } from \"../../constant\";\nimport { TS } from \"../../../type/type\";\nimport { BeforeVisitorOptions } from \"../before-visitor-options\";\nimport { VisitorContext } from \"../../visitor-context\";\nimport { pickServiceOrImplementationName } from \"../util\";\n\nexport function visitClassLikeDeclaration(\n  options: BeforeVisitorOptions<TS.ClassLikeDeclaration>\n): TS.VisitResult<TS.Node> {\n  const { node, childContinuation, continuation, context } = options;\n  const { typescript, factory } = context;\n  const constructorDeclaration = node.members.find(\n    typescript.isConstructorDeclaration\n  );\n\n  // If there are no constructor declaration for the ClassLikeDeclaration, there's nothing to do\n  if (constructorDeclaration == null) {\n    return childContinuation(node);\n  }\n\n  const updatedClassMembers: readonly TS.ClassElement[] = [\n    ...(node.members.map(continuation) as TS.ClassElement[]),\n    factory.createGetAccessorDeclaration(\n      undefined,\n      [\n        factory.createModifier(typescript.SyntaxKind.PublicKeyword),\n        factory.createModifier(typescript.SyntaxKind.StaticKeyword),\n      ],\n      factory.createComputedPropertyName(\n        factory.createIdentifier(\n          `Symbol.for(\"${CONSTRUCTOR_ARGUMENTS_SYMBOL_IDENTIFIER}\")`\n        )\n      ),\n      [],\n      undefined,\n      factory.createBlock([\n        factory.createReturnStatement(\n          getParameterTypeNamesAsArrayLiteral(\n            constructorDeclaration.parameters,\n            context\n          )\n        ),\n      ])\n    ),\n  ];\n\n  if (typescript.isClassDeclaration(node)) {\n    return factory.updateClassDeclaration(\n      node,\n      node.decorators,\n      node.modifiers,\n      node.name,\n      node.typeParameters,\n      node.heritageClauses,\n      updatedClassMembers\n    );\n  } else {\n    return factory.updateClassExpression(\n      node,\n      node.decorators,\n      node.modifiers,\n      node.name,\n      node.typeParameters,\n      node.heritageClauses,\n      updatedClassMembers\n    );\n  }\n}\n\n/**\n * Takes ConstructorParams for the given NodeArray of ParameterDeclarations\n */\nfunction getParameterTypeNamesAsArrayLiteral(\n  parameters: TS.NodeArray<TS.ParameterDeclaration>,\n  context: VisitorContext\n): TS.ArrayLiteralExpression {\n  const { factory } = context;\n  const constructorParams: TS.Expression[] = [];\n\n  for (let i = 0; i < parameters.length; i++) {\n    const parameter = parameters[i];\n    // If the parameter has no type, there's nothing to extract\n    if (parameter.type == null) {\n      constructorParams[i] = factory.createIdentifier(\"undefined\");\n    } else {\n      constructorParams[i] = factory.createNoSubstitutionTemplateLiteral(\n        pickServiceOrImplementationName(parameter.type, context)\n      );\n    }\n  }\n\n  return factory.createArrayLiteralExpression(constructorParams);\n}\n","import { TS } from \"../type/type\";\nimport { ImportedSymbol } from \"../type/imported-symbol\";\nimport { VisitorContext } from \"../transformer/visitor-context\";\nimport { RootBlock } from \"../type/root-block\";\n\ntype TSWithHelpers = typeof TS & {\n  importDefaultHelper?: TS.EmitHelper;\n  importStarHelper?: TS.EmitHelper;\n};\n\n// For some TypeScript versions, such as 3.1, these helpers are not exposed by TypeScript,\n// so they will have to be duplicated and reused from here in these rare cases\nconst HELPERS = {\n  importDefaultHelper: {\n    name: \"typescript:commonjsimportdefault\",\n    scoped: false,\n    text: '\\nvar __importDefault = (this && this.__importDefault) || function (mod) {\\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\\n};',\n  },\n  importStarHelper: {\n    name: \"typescript:commonjsimportstar\",\n    scoped: false,\n    text: '\\nvar __importStar = (this && this.__importStar) || function (mod) {\\n    if (mod && mod.__esModule) return mod;\\n    var result = {};\\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\\n    result[\"default\"] = mod;\\n    return result;\\n};',\n  },\n} as const;\n\nexport function getImportDefaultHelper(\n  typescript: TSWithHelpers\n): TS.EmitHelper {\n  return typescript.importDefaultHelper ?? HELPERS.importDefaultHelper;\n}\n\nexport function getImportStarHelper(typescript: TSWithHelpers): TS.EmitHelper {\n  return typescript.importStarHelper ?? HELPERS.importStarHelper;\n}\n\nexport function moduleKindSupportsImportHelpers(\n  moduleKind: TS.ModuleKind = TS.ModuleKind.CommonJS,\n  typescript: typeof TS\n): boolean {\n  switch (moduleKind) {\n    case typescript.ModuleKind.CommonJS:\n    case typescript.ModuleKind.UMD:\n    case typescript.ModuleKind.AMD:\n      return true;\n    default:\n      return false;\n  }\n}\n\nexport function moduleKindDefinesDependencies(\n  moduleKind: TS.ModuleKind = TS.ModuleKind.CommonJS,\n  typescript: typeof TS\n): boolean {\n  switch (moduleKind) {\n    case typescript.ModuleKind.UMD:\n    case typescript.ModuleKind.AMD:\n      return true;\n    default:\n      return false;\n  }\n}\n\ninterface EmitHelperFactory {\n  getUnscopedHelperName(helperName: string): TS.Identifier;\n}\n\ntype TSWithEmitHelpers = typeof TS &\n  (\n    | EmitHelperFactory\n    | {\n        createEmitHelperFactory(\n          factory: TS.TransformationContext\n        ): EmitHelperFactory;\n      }\n    | {\n        getHelperName(helperName: string): TS.Identifier;\n      }\n  );\n\nexport function getUnscopedHelperName(\n  context: VisitorContext,\n  helperName: string\n): TS.Identifier {\n  const typescript = context.typescript as TSWithEmitHelpers;\n  if (\"getUnscopedHelperName\" in typescript) {\n    return typescript.getUnscopedHelperName(helperName);\n  } else if (\"createEmitHelperFactory\" in typescript) {\n    return typescript\n      .createEmitHelperFactory(context.transformationContext)\n      .getUnscopedHelperName(helperName);\n  } else {\n    return typescript.getHelperName(helperName);\n  }\n}\n\nexport function getRootBlockInsertionPosition(\n  rootBlock: RootBlock,\n  typescript: typeof TS\n): number {\n  let insertPosition = 0;\n\n  for (let i = 0; i < rootBlock.statements.length; i++) {\n    const statement = rootBlock.statements[i];\n\n    const isUseStrict =\n      typescript.isExpressionStatement(statement) &&\n      typescript.isStringLiteralLike(statement.expression) &&\n      statement.expression.text === \"use strict\";\n\n    const isEsModuleSymbol =\n      typescript.isExpressionStatement(statement) &&\n      typescript.isCallExpression(statement.expression) &&\n      typescript.isPropertyAccessExpression(statement.expression.expression) &&\n      typescript.isIdentifier(statement.expression.expression.expression) &&\n      typescript.isIdentifier(statement.expression.expression.name) &&\n      statement.expression.expression.expression.text === \"Object\" &&\n      statement.expression.expression.name.text === \"defineProperty\" &&\n      statement.expression.arguments.length >= 2 &&\n      typescript.isIdentifier(statement.expression.arguments[0]) &&\n      statement.expression.arguments[0].text === \"exports\" &&\n      typescript.isStringLiteralLike(statement.expression.arguments[1]) &&\n      statement.expression.arguments[1].text === \"__esModule\";\n\n    if (isUseStrict || isEsModuleSymbol) {\n      insertPosition = Math.max(insertPosition, i + 1);\n    }\n  }\n  return insertPosition;\n}\n\nexport function getDefineArrayLiteralExpression(\n  sourceFile: TS.SourceFile,\n  context: VisitorContext\n): TS.ArrayLiteralExpression | undefined {\n  const { program, typescript } = context;\n  const compilerOptions = program.getCompilerOptions();\n\n  switch (compilerOptions.module) {\n    case typescript.ModuleKind.ESNext:\n    case typescript.ModuleKind.ES2015:\n    case typescript.ModuleKind.ES2020:\n      // There are no such thing for these module types\n      return undefined;\n\n    // If we're targeting UMD, the root block won't be the root scope, but the Function Body of an iife\n    case typescript.ModuleKind.UMD: {\n      for (const statement of sourceFile.statements) {\n        if (\n          typescript.isExpressionStatement(statement) &&\n          typescript.isCallExpression(statement.expression) &&\n          typescript.isParenthesizedExpression(\n            statement.expression.expression\n          ) &&\n          typescript.isFunctionExpression(\n            statement.expression.expression.expression\n          ) &&\n          statement.expression.expression.expression.parameters.length === 1\n        ) {\n          const [firstParameter] =\n            statement.expression.expression.expression.parameters;\n          if (typescript.isIdentifier(firstParameter.name)) {\n            if (firstParameter.name.text === \"factory\") {\n              for (const subStatement of statement.expression.expression\n                .expression.body.statements) {\n                if (\n                  typescript.isIfStatement(subStatement) &&\n                  subStatement.elseStatement != null &&\n                  typescript.isIfStatement(subStatement.elseStatement) &&\n                  typescript.isBlock(subStatement.elseStatement.thenStatement)\n                ) {\n                  for (const subSubStatement of subStatement.elseStatement\n                    .thenStatement.statements) {\n                    if (\n                      typescript.isExpressionStatement(subSubStatement) &&\n                      typescript.isCallExpression(subSubStatement.expression) &&\n                      subSubStatement.expression.arguments.length === 2 &&\n                      typescript.isIdentifier(\n                        subSubStatement.expression.expression\n                      ) &&\n                      subSubStatement.expression.expression.text === \"define\"\n                    ) {\n                      const [firstSubSubStatementExpressionArgument] =\n                        subSubStatement.expression.arguments;\n                      if (\n                        typescript.isArrayLiteralExpression(\n                          firstSubSubStatementExpressionArgument\n                        )\n                      ) {\n                        return firstSubSubStatementExpressionArgument;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      break;\n    }\n\n    case typescript.ModuleKind.AMD: {\n      for (const statement of sourceFile.statements) {\n        if (\n          typescript.isExpressionStatement(statement) &&\n          typescript.isCallExpression(statement.expression) &&\n          typescript.isIdentifier(statement.expression.expression) &&\n          statement.expression.expression.text === \"define\" &&\n          statement.expression.arguments.length === 2\n        ) {\n          const [firstArgument, secondArgument] =\n            statement.expression.arguments;\n          if (typescript.isArrayLiteralExpression(firstArgument)) {\n            if (\n              typescript.isFunctionExpression(secondArgument) &&\n              secondArgument.parameters.length >= 2\n            ) {\n              const [firstParameter, secondParameter] =\n                secondArgument.parameters;\n              if (\n                typescript.isIdentifier(firstParameter.name) &&\n                typescript.isIdentifier(secondParameter.name) &&\n                firstParameter.name.text === \"require\" &&\n                secondParameter.name.text === \"exports\"\n              ) {\n                return firstArgument;\n              }\n            }\n          }\n        }\n      }\n      break;\n    }\n  }\n\n  return undefined;\n}\n\nexport function getRootBlock(\n  sourceFile: TS.SourceFile,\n  context: VisitorContext\n): RootBlock {\n  const { program, typescript } = context;\n  const compilerOptions = program.getCompilerOptions();\n\n  switch (compilerOptions.module) {\n    // If we're targeting UMD, the root block won't be the root scope, but the Function Body of an iife\n    case typescript.ModuleKind.UMD: {\n      for (const statement of sourceFile.statements) {\n        if (\n          typescript.isExpressionStatement(statement) &&\n          typescript.isCallExpression(statement.expression) &&\n          statement.expression.arguments.length === 1\n        ) {\n          const [firstArgument] = statement.expression.arguments;\n          if (\n            typescript.isFunctionExpression(firstArgument) &&\n            firstArgument.parameters.length === 2\n          ) {\n            const [firstParameter, secondParameter] = firstArgument.parameters;\n            if (\n              typescript.isIdentifier(firstParameter.name) &&\n              typescript.isIdentifier(secondParameter.name) &&\n              firstParameter.name.text === \"require\" &&\n              secondParameter.name.text === \"exports\"\n            ) {\n              return firstArgument.body;\n            }\n          }\n        }\n      }\n      break;\n    }\n\n    // If we're targeting AMD, the root block won't be the root scope, but the Function Body of the\n    // anonymous function provided as a second argument to the define() function\n    case typescript.ModuleKind.AMD: {\n      for (const statement of sourceFile.statements) {\n        if (\n          typescript.isExpressionStatement(statement) &&\n          typescript.isCallExpression(statement.expression) &&\n          typescript.isIdentifier(statement.expression.expression) &&\n          statement.expression.expression.text === \"define\" &&\n          statement.expression.arguments.length === 2\n        ) {\n          const [, secondArgument] = statement.expression.arguments;\n          if (\n            typescript.isFunctionExpression(secondArgument) &&\n            secondArgument.parameters.length >= 2\n          ) {\n            const [firstParameter, secondParameter] = secondArgument.parameters;\n            if (\n              typescript.isIdentifier(firstParameter.name) &&\n              typescript.isIdentifier(secondParameter.name) &&\n              firstParameter.name.text === \"require\" &&\n              secondParameter.name.text === \"exports\"\n            ) {\n              return secondArgument.body;\n            }\n          }\n        }\n      }\n      break;\n    }\n  }\n\n  return sourceFile;\n}\n\nexport function isImportedSymbolImported(\n  importedSymbol: ImportedSymbol,\n  rootBlock: RootBlock,\n  context: VisitorContext\n): boolean {\n  const compilerOptions = context.program.getCompilerOptions();\n  const typescript = context.typescript;\n\n  switch (compilerOptions.module) {\n    case typescript.ModuleKind.ES2020:\n    case typescript.ModuleKind.ES2015:\n    case typescript.ModuleKind.ESNext: {\n      for (const statement of rootBlock.statements) {\n        if (!typescript.isImportDeclaration(statement)) continue;\n        if (!typescript.isStringLiteralLike(statement.moduleSpecifier)) {\n          continue;\n        }\n        if (statement.moduleSpecifier.text !== importedSymbol.moduleSpecifier) {\n          continue;\n        }\n        if (statement.importClause == null) {\n          continue;\n        }\n\n        if (\"isDefaultImport\" in importedSymbol) {\n          if (importedSymbol.isDefaultImport) {\n            if (statement.importClause.name == null) {\n              continue;\n            }\n            if (statement.importClause.name.text !== importedSymbol.name) {\n              continue;\n            }\n            return true;\n          } else {\n            if (statement.importClause.namedBindings == null) continue;\n            if (\n              !typescript.isNamedImports(statement.importClause.namedBindings)\n            ) {\n              continue;\n            }\n            for (const importSpecifier of statement.importClause.namedBindings\n              .elements) {\n              if (importSpecifier.name.text !== importedSymbol.name) continue;\n              return true;\n            }\n          }\n        } else if (\"isNamespaceImport\" in importedSymbol) {\n          if (statement.importClause.namedBindings == null) continue;\n          if (\n            !typescript.isNamespaceImport(statement.importClause.namedBindings)\n          ) {\n            continue;\n          }\n          if (\n            statement.importClause.namedBindings.name.text !==\n            importedSymbol.name\n          ) {\n            continue;\n          }\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    case typescript.ModuleKind.CommonJS:\n    case typescript.ModuleKind.AMD:\n    case typescript.ModuleKind.UMD: {\n      for (const statement of rootBlock.statements) {\n        if (!typescript.isVariableStatement(statement)) continue;\n        for (const declaration of statement.declarationList.declarations) {\n          if (!typescript.isIdentifier(declaration.name)) continue;\n          if (declaration.name.text !== importedSymbol.name) continue;\n          return true;\n        }\n      }\n    }\n  }\n\n  // TODO: Add support for other module systems\n  return false;\n}\n\nexport function generateImportStatementForImportedSymbolInContext(\n  importedSymbol: ImportedSymbol,\n  context: VisitorContext\n): TS.Statement | undefined {\n  const compilerOptions = context.program.getCompilerOptions();\n  const { factory, typescript } = context;\n\n  switch (compilerOptions.module) {\n    case typescript.ModuleKind.ES2020:\n    case typescript.ModuleKind.ES2015:\n    case typescript.ModuleKind.ESNext: {\n      return factory.createImportDeclaration(\n        undefined,\n        undefined,\n        \"isDefaultImport\" in importedSymbol\n          ? factory.createImportClause(\n              false,\n              !importedSymbol.isDefaultImport\n                ? undefined\n                : factory.createIdentifier(importedSymbol.name),\n              importedSymbol.isDefaultImport\n                ? undefined\n                : factory.createNamedImports([\n                    factory.createImportSpecifier(\n                      false,\n                      importedSymbol.propertyName === importedSymbol.name\n                        ? undefined\n                        : factory.createIdentifier(importedSymbol.propertyName),\n                      factory.createIdentifier(importedSymbol.name)\n                    ),\n                  ])\n            )\n          : \"isNamespaceImport\" in importedSymbol\n          ? factory.createImportClause(\n              false,\n              undefined,\n              factory.createNamespaceImport(\n                factory.createIdentifier(importedSymbol.name)\n              )\n            )\n          : undefined,\n        factory.createStringLiteral(importedSymbol.moduleSpecifier)\n      );\n    }\n\n    case typescript.ModuleKind.CommonJS:\n    case typescript.ModuleKind.AMD:\n    case typescript.ModuleKind.UMD: {\n      const requireCall = factory.createCallExpression(\n        factory.createIdentifier(\"require\"),\n        undefined,\n        [factory.createStringLiteral(importedSymbol.moduleSpecifier)]\n      );\n\n      let wrappedRequireCall = requireCall;\n\n      // We'll need to use a helper, '__importDefault', and wrap the require call with it\n      if (\n        compilerOptions.esModuleInterop === true &&\n        ((\"isDefaultImport\" in importedSymbol &&\n          importedSymbol.isDefaultImport) ||\n          (!(\"isDefaultImport\" in importedSymbol) &&\n            importedSymbol.isNamespaceImport))\n      ) {\n        // If tslib is being used, we can do something like 'require(\"tslib\").__import{Default|Star}(<requireCall>)'\n        if (compilerOptions.importHelpers === true) {\n          wrappedRequireCall = factory.createCallExpression(\n            factory.createPropertyAccessExpression(\n              factory.createCallExpression(\n                factory.createIdentifier(\"require\"),\n                undefined,\n                [factory.createStringLiteral(\"tslib\")]\n              ),\n              getUnscopedHelperName(\n                context,\n                \"isDefaultImport\" in importedSymbol\n                  ? \"__importDefault\"\n                  : \"__importStar\"\n              )\n            ),\n            undefined,\n            [requireCall]\n          );\n        }\n\n        // Otherwise, we'll have to make sure that the helper is being inlined in an transformation step later\n        else {\n          // We've already requested the __importDefault helper in the before transformer under these\n          // circumstances\n          wrappedRequireCall = factory.createCallExpression(\n            getUnscopedHelperName(\n              context,\n              \"isDefaultImport\" in importedSymbol\n                ? \"__importDefault\"\n                : \"__importStar\"\n            ),\n            undefined,\n            [requireCall]\n          );\n        }\n      }\n\n      return factory.createVariableStatement(\n        undefined,\n        factory.createVariableDeclarationList(\n          [\n            factory.createVariableDeclaration(\n              factory.createIdentifier(importedSymbol.name),\n              undefined,\n              undefined,\n              wrappedRequireCall\n            ),\n          ],\n          typescript.NodeFlags.Const\n        )\n      );\n    }\n  }\n\n  // TODO: Handle other module types as well\n  return undefined;\n}\n","import { DI_CONTAINER_NAME } from \"../../constant\";\nimport { TS } from \"../../../type/type\";\nimport { BeforeVisitorOptions } from \"../before-visitor-options\";\nimport { DiMethodKind } from \"../../di-method-kind\";\nimport { VisitorContext } from \"../../visitor-context\";\nimport {\n  getImportDefaultHelper,\n  getImportStarHelper,\n  moduleKindDefinesDependencies,\n  moduleKindSupportsImportHelpers,\n} from \"../../../util/ts-util\";\nimport { pickServiceOrImplementationName } from \"../util\";\n\nexport function visitCallExpression(\n  options: BeforeVisitorOptions<TS.CallExpression>\n): TS.VisitResult<TS.Node> {\n  const {\n    node,\n    childContinuation,\n    continuation,\n    context,\n    addTslibDefinition,\n    requireImportedSymbol,\n  } = options;\n  const { typescript, factory, transformationContext } = context;\n\n  const diMethod = getDiMethodKind(node.expression, context);\n\n  if (diMethod != null) {\n    switch (diMethod) {\n      case DiMethodKind.GET:\n      case DiMethodKind.HAS: {\n        // If no type arguments are given, don't modify the node at all\n        if (node.typeArguments == null || node.typeArguments[0] == null) {\n          return childContinuation(node);\n        }\n\n        return factory.updateCallExpression(\n          node,\n          node.expression,\n          node.typeArguments,\n          [\n            factory.createObjectLiteralExpression([\n              factory.createPropertyAssignment(\n                \"identifier\",\n                factory.createStringLiteral(\n                  node.typeArguments[0].getFirstToken()!.getFullText().trim()\n                )\n              ),\n            ]),\n          ]\n        );\n      }\n\n      case DiMethodKind.REGISTER_SINGLETON:\n      case DiMethodKind.REGISTER_TRANSIENT: {\n        let [typeArg, implementationArg] = (node.typeArguments ??\n          []) as unknown as [\n          TS.TypeNode | undefined,\n          TS.TypeNode | TS.Expression | undefined\n        ];\n\n        // If not implementation is provided, use the type argument *as* the implementation\n        if (implementationArg == null) {\n          implementationArg = typeArg;\n        }\n\n        // If another implementation is passed, used that one instead\n        if (node.arguments.length > 0) {\n          implementationArg = node.arguments[0];\n        }\n\n        if (typeArg == null || implementationArg == null) {\n          return childContinuation(node);\n        }\n\n        const typeArgText = pickServiceOrImplementationName(typeArg, context);\n        const implementationArgText = pickServiceOrImplementationName(\n          implementationArg,\n          context\n        );\n\n        // If the Implementation is a TypeNode, and if it originates from an ImportDeclaration, it may be stripped from the file since Typescript won't Type-check the updates from\n        // a CustomTransformer and such a node would normally be removed from the imports.\n        // to fix it, add an ImportDeclaration if needed\n        if (typescript.isTypeNode(implementationArg)) {\n          const matchingImport = findMatchingImportDeclarationForIdentifier(\n            implementationArgText,\n            options\n          );\n          if (\n            matchingImport != null &&\n            typescript.isStringLiteralLike(\n              matchingImport.importDeclaration.moduleSpecifier\n            )\n          ) {\n            switch (matchingImport.kind) {\n              case \"default\": {\n                const compilerOptions = context.program.getCompilerOptions();\n\n                // Log a request for the __importDefault helper already if we will\n                // need it in a later transformation step\n                if (\n                  moduleKindSupportsImportHelpers(\n                    compilerOptions.module,\n                    typescript\n                  ) &&\n                  compilerOptions.esModuleInterop === true &&\n                  compilerOptions.importHelpers !== true\n                ) {\n                  transformationContext.requestEmitHelper(\n                    getImportDefaultHelper(typescript)\n                  );\n                }\n\n                // Log a request for adding 'tslib' to the define([...]) array for the current\n                // module system if it relies on declaring dependencies (such as UMD, AMD, and SystemJS does)\n                if (\n                  moduleKindDefinesDependencies(\n                    compilerOptions.module,\n                    typescript\n                  ) &&\n                  compilerOptions.esModuleInterop === true &&\n                  compilerOptions.importHelpers === true\n                ) {\n                  addTslibDefinition();\n                }\n\n                requireImportedSymbol({\n                  isDefaultImport: true,\n                  moduleSpecifier:\n                    matchingImport.importDeclaration.moduleSpecifier.text,\n                  name: matchingImport.identifier.text,\n                  propertyName: matchingImport.identifier.text,\n                });\n                break;\n              }\n\n              case \"namedImport\": {\n                requireImportedSymbol({\n                  isDefaultImport: false,\n                  moduleSpecifier:\n                    matchingImport.importDeclaration.moduleSpecifier.text,\n                  name: matchingImport.importSpecifier.name.text,\n                  propertyName:\n                    matchingImport.importSpecifier.propertyName?.text ??\n                    matchingImport.importSpecifier.name.text,\n                });\n                break;\n              }\n\n              case \"namespace\": {\n                const compilerOptions = context.program.getCompilerOptions();\n\n                // Log a request for the __importStar helper already if you will\n                // need it in a later transformation step\n                if (\n                  moduleKindSupportsImportHelpers(\n                    compilerOptions.module,\n                    typescript\n                  ) &&\n                  compilerOptions.esModuleInterop === true &&\n                  compilerOptions.importHelpers !== true\n                ) {\n                  transformationContext.requestEmitHelper(\n                    getImportStarHelper(typescript)\n                  );\n                }\n\n                requireImportedSymbol({\n                  isNamespaceImport: true,\n                  moduleSpecifier:\n                    matchingImport.importDeclaration.moduleSpecifier.text,\n                  name: matchingImport.identifier.text,\n                });\n                break;\n              }\n            }\n          }\n        }\n\n        return factory.updateCallExpression(\n          node,\n          node.expression,\n          node.typeArguments,\n          [\n            typescript.isTypeNode(implementationArg)\n              ? factory.createIdentifier(\"undefined\")\n              : (continuation(implementationArg) as TS.Expression),\n            factory.createObjectLiteralExpression([\n              factory.createPropertyAssignment(\n                \"identifier\",\n                factory.createNoSubstitutionTemplateLiteral(typeArgText)\n              ),\n              ...(!typescript.isTypeNode(implementationArg)\n                ? []\n                : [\n                    factory.createPropertyAssignment(\n                      \"implementation\",\n                      factory.createIdentifier(\n                        rewriteImplementationName(\n                          implementationArgText,\n                          options\n                        )\n                      )\n                    ),\n                  ]),\n            ]),\n          ]\n        );\n      }\n    }\n  }\n\n  return childContinuation(node);\n}\n\ninterface FindMatchingImportDeclarationForIdentifierBaseResult {\n  kind: \"default\" | \"namespace\" | \"namedImport\";\n  importDeclaration: TS.ImportDeclaration;\n}\n\ninterface FindMatchingImportDeclarationForIdentifierNamedImportResult\n  extends FindMatchingImportDeclarationForIdentifierBaseResult {\n  kind: \"namedImport\";\n  importSpecifier: TS.ImportSpecifier;\n}\n\ninterface FindMatchingImportDeclarationForIdentifierDefaultResult\n  extends FindMatchingImportDeclarationForIdentifierBaseResult {\n  kind: \"default\";\n  identifier: TS.Identifier;\n}\n\ninterface FindMatchingImportDeclarationForIdentifierNamespaceResult\n  extends FindMatchingImportDeclarationForIdentifierBaseResult {\n  kind: \"namespace\";\n  identifier: TS.Identifier;\n}\n\ntype FindMatchingImportDeclarationForIdentifierResult =\n  | FindMatchingImportDeclarationForIdentifierNamedImportResult\n  | FindMatchingImportDeclarationForIdentifierDefaultResult\n  | FindMatchingImportDeclarationForIdentifierNamespaceResult;\n\nfunction findMatchingImportDeclarationForIdentifier(\n  identifier: string,\n  options: BeforeVisitorOptions<TS.CallExpression>\n): FindMatchingImportDeclarationForIdentifierResult | undefined {\n  const {\n    sourceFile,\n    context: { typescript },\n  } = options;\n\n  // Find the matching import\n  const importDeclarations = sourceFile.statements.filter(\n    typescript.isImportDeclaration\n  );\n\n  for (const importDeclaration of importDeclarations) {\n    if (importDeclaration.importClause == null) continue;\n\n    // Default import\n    if (importDeclaration.importClause.name?.text === identifier) {\n      return {\n        importDeclaration,\n        kind: \"default\",\n        identifier: importDeclaration.importClause.name,\n      };\n    } else if (importDeclaration.importClause.namedBindings != null) {\n      if (\n        typescript.isNamespaceImport(\n          importDeclaration.importClause.namedBindings\n        )\n      ) {\n        if (\n          importDeclaration.importClause.namedBindings.name.text === identifier\n        ) {\n          return {\n            importDeclaration,\n            kind: \"namespace\",\n            identifier: importDeclaration.importClause.namedBindings.name,\n          };\n        }\n      } else {\n        for (const importSpecifier of importDeclaration.importClause\n          .namedBindings.elements) {\n          if (importSpecifier.name.text === identifier) {\n            return {\n              importDeclaration,\n              kind: \"namedImport\",\n              importSpecifier: importSpecifier,\n            };\n          }\n        }\n      }\n    }\n  }\n\n  // No import was matched\n  return undefined;\n}\n\nfunction rewriteImplementationName(\n  name: string,\n  options: BeforeVisitorOptions<TS.CallExpression>\n): string {\n  const {\n    context: { typescript },\n  } = options;\n  const compilerOptions = options.context.program.getCompilerOptions();\n\n  switch (compilerOptions.module) {\n    case typescript.ModuleKind.ES2020:\n    case typescript.ModuleKind.ES2015:\n    case typescript.ModuleKind.ESNext:\n      return name;\n\n    case typescript.ModuleKind.CommonJS:\n    case typescript.ModuleKind.AMD:\n    case typescript.ModuleKind.UMD: {\n      // Find the matching import\n      const match = findMatchingImportDeclarationForIdentifier(name, options);\n      if (match == null) {\n        return name;\n      }\n\n      switch (match.kind) {\n        case \"default\":\n          return `${name}.default`;\n        case \"namespace\":\n          return name;\n        case \"namedImport\":\n          return `${name}.${\n            (match.importSpecifier.propertyName ?? match.importSpecifier.name)\n              .text\n          }`;\n      }\n\n      // Fall back to returning the original name\n      return name;\n    }\n\n    default:\n      // TODO: Add support for SystemJS here\n      return name;\n  }\n}\n\nfunction getDiMethodKind(\n  node: TS.Expression,\n  context: VisitorContext\n): DiMethodKind | undefined {\n  if (\n    !context.typescript.isPropertyAccessExpression(node) &&\n    !context.typescript.isElementAccessExpression(node)\n  ) {\n    return undefined;\n  }\n\n  // Don't proceed unless the left-hand expression is the DIServiceContainer\n  const type = context.typeChecker.getTypeAtLocation(node.expression);\n\n  if (\n    type == null ||\n    type.symbol == null ||\n    type.symbol.escapedName !== DI_CONTAINER_NAME\n  ) {\n    return undefined;\n  }\n\n  let name: string;\n\n  // If it is an element access expression, evaluate the argument expression\n  if (context.typescript.isElementAccessExpression(node)) {\n    const evaluationResult = context.evaluate(node.argumentExpression);\n\n    // If no value could be computed, or if the value isn't of type string, do nothing\n    if (\n      !evaluationResult.success ||\n      typeof evaluationResult.value !== \"string\"\n    ) {\n      return undefined;\n    } else {\n      name = evaluationResult.value;\n    }\n  } else {\n    name = node.name.text;\n  }\n\n  switch (name) {\n    case DiMethodKind.GET:\n    case DiMethodKind.HAS:\n    case DiMethodKind.REGISTER_SINGLETON:\n    case DiMethodKind.REGISTER_TRANSIENT:\n      return name;\n    default:\n      return undefined;\n  }\n}\n","import { BeforeVisitorOptions } from \"../before-visitor-options\";\nimport { TS } from \"../../../type/type\";\nimport { visitClassLikeDeclaration } from \"./visit-class-like-declaration\";\nimport { visitCallExpression } from \"./visit-call-expression\";\n\nexport function visitNode<T extends TS.Node>(\n  options: BeforeVisitorOptions<T>\n): TS.VisitResult<TS.Node> {\n  if (options.context.typescript.isClassLike(options.node)) {\n    return visitClassLikeDeclaration({ ...options, node: options.node });\n  } else if (options.context.typescript.isCallExpression(options.node)) {\n    return visitCallExpression({ ...options, node: options.node });\n  }\n\n  return options.childContinuation(options.node);\n}\n","import { BaseVisitorContext, VisitorContext } from \"../visitor-context\";\nimport { TS } from \"../../type/type\";\nimport { BeforeVisitorOptions } from \"./before-visitor-options\";\nimport { visitNode } from \"./visitor/visit-node\";\nimport { ImportedSymbol } from \"../../type/imported-symbol\";\nimport { ensureNodeFactory } from \"compatfactory\";\n\nexport function beforeTransformer(\n  context: BaseVisitorContext\n): TS.TransformerFactory<TS.SourceFile> {\n  return (transformationContext) => {\n    const factory = ensureNodeFactory(\n      transformationContext.factory ?? context.typescript\n    );\n\n    return (sourceFile) =>\n      transformSourceFile(sourceFile, {\n        ...context,\n        transformationContext,\n        factory,\n      });\n  };\n}\n\nfunction transformSourceFile(\n  sourceFile: TS.SourceFile,\n  context: VisitorContext\n): TS.SourceFile {\n  const requiredImportedSymbolSet = new Set<ImportedSymbol>();\n\n  /**\n   * An optimization in which every imported symbol is converted into\n   * a string that can be matched against directly to guard against\n   * duplicates\n   */\n  const requiredImportedSymbolSetFlags = new Set<string>();\n\n  context.sourceFileToAddTslibDefinition.set(sourceFile.fileName, false);\n  context.sourceFileToRequiredImportedSymbolSet.set(\n    sourceFile.fileName,\n    requiredImportedSymbolSet\n  );\n\n  const computeImportedSymbolFlag = (symbol: ImportedSymbol): string =>\n    [\n      \"name\",\n      \"propertyName\",\n      \"moduleSpecifier\",\n      \"isNamespaceImport\",\n      \"isDefaultImport\",\n    ]\n      .map(\n        (property) =>\n          `${property}:${symbol[property as keyof ImportedSymbol] ?? false}`\n      )\n      .join(\"|\");\n\n  const visitorOptions: Omit<\n    BeforeVisitorOptions<TS.Node>,\n    \"node\" | \"sourceFile\"\n  > = {\n    context,\n\n    addTslibDefinition: (): void => {\n      context.sourceFileToAddTslibDefinition.set(sourceFile.fileName, true);\n    },\n\n    requireImportedSymbol: (importedSymbol: ImportedSymbol): void => {\n      // Guard against duplicates and compute a string so we can do\n      // constant time lookups to compare against existing symbols\n      const flag = computeImportedSymbolFlag(importedSymbol);\n      if (requiredImportedSymbolSetFlags.has(flag)) return;\n      requiredImportedSymbolSetFlags.add(flag);\n\n      requiredImportedSymbolSet.add(importedSymbol);\n    },\n\n    continuation: (node) =>\n      visitNode({\n        ...visitorOptions,\n        sourceFile,\n        node,\n      }),\n    childContinuation: (node) =>\n      context.typescript.visitEachChild(\n        node,\n        (cbNode) =>\n          visitNode({\n            ...visitorOptions,\n            sourceFile,\n            node: cbNode,\n          }),\n        context.transformationContext\n      ),\n  };\n\n  return visitorOptions.continuation(sourceFile) as TS.SourceFile;\n}\n","import { TS } from \"../../../type/type\";\nimport { AfterVisitorOptions } from \"../after-visitor-options\";\nimport {\n  generateImportStatementForImportedSymbolInContext,\n  getRootBlockInsertionPosition,\n  isImportedSymbolImported,\n} from \"../../../util/ts-util\";\nimport { RootBlock } from \"../../../type/root-block\";\n\nexport function visitRootBlock(\n  options: AfterVisitorOptions<RootBlock>\n): TS.Statement[] {\n  const { node, sourceFile, context } = options;\n  const { typescript } = context;\n\n  const leadingExtraStatements: TS.Statement[] = [];\n\n  for (const importedSymbol of context.sourceFileToRequiredImportedSymbolSet.get(\n    sourceFile.fileName\n  ) ?? new Set()) {\n    if (isImportedSymbolImported(importedSymbol, node, context)) continue;\n\n    const missingImportStatement = generateImportStatementForImportedSymbolInContext(\n      importedSymbol,\n      context\n    );\n\n    if (missingImportStatement != null) {\n      leadingExtraStatements.push(missingImportStatement);\n    }\n  }\n\n  const insertPosition = getRootBlockInsertionPosition(node, typescript);\n\n  return [\n    ...node.statements.slice(0, insertPosition),\n    ...leadingExtraStatements,\n    ...node.statements.slice(insertPosition),\n  ];\n}\n","import { TS } from \"../../../type/type\";\nimport { AfterVisitorOptions } from \"../after-visitor-options\";\nimport { visitRootBlock } from \"./visit-root-block\";\n\nexport function visitRootBlockSourceFile(\n  options: AfterVisitorOptions<TS.SourceFile>\n): TS.VisitResult<TS.Node> {\n  const { node, context } = options;\n  const { factory } = context;\n\n  return factory.updateSourceFile(\n    node,\n    visitRootBlock(options),\n    node.isDeclarationFile,\n    node.referencedFiles,\n    node.typeReferenceDirectives,\n    node.hasNoDefaultLib,\n    node.libReferenceDirectives\n  );\n}\n","import { TS } from \"../../../type/type\";\nimport { AfterVisitorOptions } from \"../after-visitor-options\";\nimport { visitRootBlock } from \"./visit-root-block\";\n\nexport function visitRootBlockBlock(\n  options: AfterVisitorOptions<TS.Block>\n): TS.VisitResult<TS.Node> {\n  const { node, context } = options;\n  const { factory } = context;\n\n  return factory.updateBlock(node, visitRootBlock(options));\n}\n","import { TS } from \"../../../type/type\";\nimport { AfterVisitorOptions } from \"../after-visitor-options\";\n\nexport function visitDefineArrayLiteralExpression(\n  options: AfterVisitorOptions<TS.ArrayLiteralExpression>\n): TS.ArrayLiteralExpression {\n  const { node, sourceFile, context } = options;\n  const { typescript, factory } = context;\n\n  const trailingExtraExpressions: TS.Expression[] = [];\n\n  for (const importedSymbol of context.sourceFileToRequiredImportedSymbolSet.get(\n    sourceFile.fileName\n  ) ?? new Set()) {\n    // Skip the node if it is already declared as a dependency\n    if (\n      node.elements.some(\n        (element) =>\n          typescript.isStringLiteralLike(element) &&\n          element.text === importedSymbol.moduleSpecifier\n      )\n    ) {\n      continue;\n    }\n\n    trailingExtraExpressions.push(\n      factory.createStringLiteral(importedSymbol.moduleSpecifier)\n    );\n  }\n\n  if (\n    context.sourceFileToAddTslibDefinition.get(sourceFile.fileName) === true\n  ) {\n    trailingExtraExpressions.push(factory.createStringLiteral(\"tslib\"));\n  }\n\n  if (trailingExtraExpressions.length < 1) {\n    return node;\n  }\n\n  return factory.updateArrayLiteralExpression(node, [\n    ...node.elements,\n    ...trailingExtraExpressions,\n  ]);\n}\n","import { TS } from \"../../../type/type\";\nimport { visitRootBlockSourceFile } from \"./visit-root-block-source-file\";\nimport { AfterVisitorOptions } from \"../after-visitor-options\";\nimport { visitRootBlockBlock } from \"./visit-root-block-block\";\nimport { visitDefineArrayLiteralExpression } from \"./visit-define-array-literal-expression\";\n\nexport function visitNode<T extends TS.Node>(\n  options: AfterVisitorOptions<T>\n): TS.VisitResult<TS.Node> {\n  const {\n    node,\n    childContinuation,\n    defineArrayLiteralExpression,\n    rootBlock,\n    context: { typescript },\n  } = options;\n  if (typescript.isSourceFile(node) && rootBlock === node) {\n    return visitRootBlockSourceFile({ ...options, node });\n  } else if (typescript.isBlock(node) && rootBlock === node) {\n    return visitRootBlockBlock({ ...options, node });\n  } else if (\n    typescript.isArrayLiteralExpression(node) &&\n    defineArrayLiteralExpression === node\n  ) {\n    return visitDefineArrayLiteralExpression({\n      ...options,\n      node,\n    });\n  }\n\n  return childContinuation(options.node);\n}\n","import { BaseVisitorContext, VisitorContext } from \"../visitor-context\";\nimport { TS } from \"../../type/type\";\nimport { AfterVisitorOptions } from \"./after-visitor-options\";\nimport { visitNode } from \"./visitor/visit-node\";\nimport {\n  getDefineArrayLiteralExpression,\n  getRootBlock,\n} from \"../../util/ts-util\";\nimport { ensureNodeFactory } from \"compatfactory\";\n\ntype SourceFileWithEmitNodes = TS.SourceFile & {\n  emitNode?: {\n    helpers?: TS.EmitHelper[];\n  };\n};\n\nexport function afterTransformer(\n  context: BaseVisitorContext\n): TS.TransformerFactory<TS.SourceFile> {\n  return (transformationContext) => {\n    const factory = ensureNodeFactory(\n      transformationContext.factory ?? context.typescript\n    );\n\n    return (sourceFile) =>\n      transformSourceFile(sourceFile, {\n        ...context,\n        transformationContext,\n        factory,\n      });\n  };\n}\n\nfunction transformSourceFile(\n  sourceFile: SourceFileWithEmitNodes,\n  context: VisitorContext\n): TS.SourceFile {\n  // For TypeScript versions below 3.5, there may be instances\n  // where EmitHelpers such as __importDefault or __importStar is duplicated.\n  // For these TypeScript versions, well have to guard against this behavior\n  if (sourceFile.emitNode != null && sourceFile.emitNode.helpers != null) {\n    const seenNames = new Set();\n    const filtered = sourceFile.emitNode.helpers.filter((helper) => {\n      if (seenNames.has(helper.name)) return false;\n      seenNames.add(helper.name);\n      return true;\n    });\n\n    // Reassign the emitNodes if they changed\n    if (filtered.length !== sourceFile.emitNode.helpers.length) {\n      sourceFile.emitNode.helpers = filtered;\n    }\n  }\n\n  const visitorOptions: Omit<\n    AfterVisitorOptions<TS.Node>,\n    \"node\" | \"sourceFile\"\n  > = {\n    context,\n    defineArrayLiteralExpression: getDefineArrayLiteralExpression(\n      sourceFile,\n      context\n    ),\n    rootBlock: getRootBlock(sourceFile, context),\n\n    continuation: (node) =>\n      visitNode({\n        ...visitorOptions,\n        sourceFile,\n        node,\n      }),\n    childContinuation: (node) =>\n      context.typescript.visitEachChild(\n        node,\n        (cbNode) =>\n          visitNode({\n            ...visitorOptions,\n            sourceFile,\n            node: cbNode,\n          }),\n        context.transformationContext\n      ),\n  };\n\n  return visitorOptions.continuation(sourceFile) as TS.SourceFile;\n}\n","import { TS } from \"../type/type\";\nimport { DiOptions } from \"./di-options\";\nimport { BaseVisitorContext } from \"./visitor-context\";\nimport { evaluate } from \"ts-evaluator\";\nimport * as TSModule from \"typescript\";\nimport { beforeTransformer } from \"./before/before-transformer\";\nimport { afterTransformer } from \"./after/after-transformer\";\n\n/**\n * CustomTransformer that associates constructor arguments with any given class declaration\n */\nexport function di({\n  typescript = TSModule,\n  ...rest\n}: DiOptions): TS.CustomTransformers {\n  const typeChecker = rest.program.getTypeChecker();\n\n  // Prepare a VisitorContext\n  const visitorContext: BaseVisitorContext = {\n    ...rest,\n    typescript,\n    typeChecker,\n    sourceFileToAddTslibDefinition: new Map(),\n    sourceFileToRequiredImportedSymbolSet: new Map(),\n    evaluate: (node) =>\n      evaluate({\n        node,\n        typeChecker,\n        typescript,\n      }),\n  };\n\n  return {\n    before: [beforeTransformer(visitorContext)],\n    after: [afterTransformer(visitorContext)],\n  };\n}\n"],"names":["TS","visitNode","ensureNodeFactory","transformSourceFile","TSModule","evaluate"],"mappings":"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"}